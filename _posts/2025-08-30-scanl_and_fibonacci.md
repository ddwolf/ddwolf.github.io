---
layout: post
title: "理解 haskell 中 由scanl 定义的 fibonacci"
date: 2025-08-30
---

# 对 haskell 定义的 `fibs=1:scanl (+) 1 fibs` 的理解
### 以 x,y 为前两元素的的 fibonacci 数列的形式为：

`f = [x, y, y + x, (y + x) + y, ((y + x) + y) +(y + x), (((y + x) + y) +(y + x)) + ((y + x) + y), …]`

#### 从第三个元素开始的数组：

1. 全都由一个加法运算组成
2. 加法的第二个加数组成的数组为
    
    [x, y, y+x, y+x+y…]，正好为 `fibonacci` 数列本身
    
3. 加法的第一个加数，正好是加数所在元素的前一个元素

#### 而 haskell 中， `scanl (+) z xs` 函数的展开形式也是一个数组，且：

1. 除了第一个元素外，每个元素都由一个加法组成
2. 元素中的一个加数来自于展开数组的前一个元素
3. 另一个加数来源于数组  `xs` 自身

#### 所以，如果我们让 `scanl (+) z xs` 中的 `xs` 等于 `fibonacci 数组` 本身， `z` 等于 `y` ，则，形式 `f` 中，从第二个元素开始的部分，我们抄写下来，记作 `f'` ，即：

`f'= [y, y+x, y+x+y, y+x+y+y+x, y+x+y+y+x+y+x+y...]` 

可以用 `scanl (+) y f` 来表示，而 `f=x:f'` ，可以得到：

`f = x: scanl (+) y f` 。

我们平时看到的 fibonacci 数列都是以 `1,1` 为前两个元素，代入上面的公式，即

`f = 1 : scanl (+) 1 f` 

写的直白一点， `fibs = 1 : scanl (+) 1 fibs` 这个定义看上去是一个递归的定义，原来，递归不只可以用于函数，也可以用于数组，是不是还挺神奇的？

写这些是因为看到了 `haskell in first principle` 中的 `fibs = 1 : scanl (+) 1 fibs` 这个定义后苦苦思考出来的。这是一个无限长的数组，所以，直接执行会 hang 住。 `haskell` lazy evaluation 可以让我们通过 `take 10 fibs` 快速拿到它的前 10 个元素。执行效果如下：

```cpp
(base) ➜  ~ ghci
GHCi, version 9.4.7: https://www.haskell.org/ghc/  :? for help
ghci> fibs = 1 : scanl (+) 1 fibs
ghci> take 10 fibs
[1,1,2,3,5,8,13,21,34,55]
```

执行 `show fibs` 会无限刷屏下去：）记得及时停掉。

```cpp
ghci> show fibs
"[1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17711,28657,46368,75025,121393,196418,317811,514229,832040,1346269,2178309,3524578,5702887,9227465,14930352,24157817,39088169,63245986,102334155,165580141,267914296,433494437,701408733,1134903170,1836311903,2971215073,4807526976,7778742049,12586269025,20365011074,32951280099,53316291173,86267571272,139583862445,225851433717,365435296162,591286729879,956722026041,1548008755920,2504730781961,4052739537881,6557470319842,10610209857723,17167680177565,27777890035288,44945570212853,72723460248141,117669030460994,190392490709135,308061521170129,498454011879264,806515533049393,1304969544928657,2111485077978050,3416454622906707,5527939700884757,8944394323791464,14472334024676221,23416728348467685,37889062373143906,61305790721611591,99194853094755497,160500643816367088,259695496911122585,420196140727489673,679891637638612258,1100087778366101931,1779979416004714189,2880067194370816120,4660046610375530309,7540113804746346429,12200160415121876738,19740274219868223167,31940434634990099905,51680708854858323072,83621143489848422977,135301852344706746049,218922995834555169026,354224848179261915075,573147844013817084101,927372692193078999176,1500520536206896083277,2427893228399975082453,3928413764606871165730,6356306993006846248183,10284720757613717413913,16641027750620563662096,26925748508234281076009,43566776258854844738105,70492524767089125814114,114059301025943970552219,184551825793033096366333,298611126818977066918552,483162952612010163284885,781774079430987230203437,1264937032042997393488322,2046711111473984623691759,3311648143516982017180081,5358359254990966640871840,8670007398507948658051921,14028366653498915298923761,22698374052006863956975682,36726740705505779255899443,59425114757512643212875125,96151855463018422468774568,155576970220531065681649693,251728825683549488150424261,407305795904080553832073954,659034621587630041982498215,1066340417491710595814572169,1725375039079340637797070384,2791715456571051233611642553,
```

原来值的递归定义在 `haskell` 中也是合法的，

`fibs = fibs ++ []` 也是可以编译的，但是运行会进入死循环，LOL，即使使用 `take 1 fibs` 也不行。
